package usecase

import (
	"context"
	"fmt"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/gigaonion/taskalyst/backend/internal/infra/repository"
)

type CalendarUsecase interface {
	CreateEvent(ctx context.Context, userID, projectID uuid.UUID, title string, startAt, endAt time.Time, isAllDay bool) (*repository.ScheduledEvent, error)
	ListEvents(ctx context.Context, userID uuid.UUID, start, end time.Time) ([]repository.ListEventsByRangeRow, error)
	
	CreateTimetableSlot(ctx context.Context, userID, projectID uuid.UUID, dayOfWeek int32, start, end time.Time, location string) (*repository.TimetableSlot, error)
	ListTimetable(ctx context.Context, userID uuid.UUID) ([]repository.ListTimetableSlotsRow, error)

	SyncDailySchedule(ctx context.Context, userID uuid.UUID, date time.Time) error
}

type calendarUsecase struct {
	repo *repository.Queries
}

func NewCalendarUsecase(repo *repository.Queries) CalendarUsecase {
	return &calendarUsecase{repo: repo}
}


func (u *calendarUsecase) CreateEvent(ctx context.Context, userID, projectID uuid.UUID, title string, startAt, endAt time.Time, isAllDay bool) (*repository.ScheduledEvent, error) {
	// デフォルトカレンダー
	calendars, err := u.repo.ListCalendars(ctx, userID)
	if err != nil {
		return nil, fmt.Errorf("failed to get default calendar: %w", err)
	}
	if len(calendars) == 0 {
		return nil, fmt.Errorf("no calendar found for user")
	}
	defaultCalendarID := calendars[0].ID
	arg := repository.CreateEventParams{
		UserID:    userID,
		ProjectID: projectID,
		CalendarID: pgtype.UUID{Bytes: defaultCalendarID, Valid: true},
		Title:     title,
		StartAt:   toTimestamp(&startAt),
		EndAt:     toTimestamp(&endAt),
		IsAllDay:  isAllDay,
		IcalUid:   pgtype.Text{String: uuid.NewString(), Valid: true},
	}
	event, err := u.repo.CreateEvent(ctx, arg)
	if err != nil {
		return nil, fmt.Errorf("failed to create event: %w", err)
	}
	return &event, nil
}

func (u *calendarUsecase) ListEvents(ctx context.Context, userID uuid.UUID, start, end time.Time) ([]repository.ListEventsByRangeRow, error) {
	events, err := u.repo.ListEventsByRange(ctx, repository.ListEventsByRangeParams{
		UserID:    userID,
		StartTime: toTimestamp(&start),
		EndTime:   toTimestamp(&end),
	})
	if err != nil {
		return nil, fmt.Errorf("failed to list events: %w", err)
	}
	return events, nil
}


func (u *calendarUsecase) CreateTimetableSlot(ctx context.Context, userID, projectID uuid.UUID, dayOfWeek int32, start, end time.Time, location string) (*repository.TimetableSlot, error) {
	
	slot, err := u.repo.CreateTimetableSlot(ctx, repository.CreateTimetableSlotParams{
		UserID:    userID,
		ProjectID: projectID,
		DayOfWeek: int16(dayOfWeek),
		StartTime: toPgTime(start),
		EndTime:   toPgTime(end),
		Location:  toTextFromStr(location),
	})
	if err != nil {
		return nil, fmt.Errorf("failed to create slot: %w", err)
	}
	return &slot, nil
}

func (u *calendarUsecase) ListTimetable(ctx context.Context, userID uuid.UUID) ([]repository.ListTimetableSlotsRow, error) {
	slots, err := u.repo.ListTimetableSlots(ctx, userID)
	if err != nil {
		return nil, fmt.Errorf("failed to list timetable: %w", err)
	}
	return slots, nil
}


func (u *calendarUsecase) SyncDailySchedule(ctx context.Context, userID uuid.UUID, targetDate time.Time) error {
	dow := int32(targetDate.Weekday())

	// クエリを用意して絞り込む
	allSlots, err := u.repo.ListTimetableSlots(ctx, userID)
	if err != nil {
		return err
	}

	for _, slot := range allSlots {
		if int32(slot.DayOfWeek) != dow {
			continue
		}
		
		start := mergeDateAndTime(targetDate, slot.StartTime.Microseconds)
		//end := mergeDateAndTime(targetDate, slot.EndTime.Microseconds)
		// Todo: 終了時間

		// Todo: AutoGeneratedフラグ
		_, err := u.repo.CreateTimeEntry(ctx, repository.CreateTimeEntryParams{
			UserID:    userID,
			ProjectID: slot.ProjectID,
			StartedAt: toTimestamp(&start),
			Note:      toTextFromStr("Auto-generated from Timetable"),
			//EndedAt: toTimestamp(&end),
		})
		if err != nil {
			fmt.Printf("failed to sync slot: %v\n", err)
		}
	}
	
	return nil
}

func toPgTime(t time.Time) pgtype.Time {
	micros := int64(t.Hour())*3600*1000000 + int64(t.Minute())*60*1000000 + int64(t.Second())*1000000
	return pgtype.Time{Microseconds: micros, Valid: true}
}

func mergeDateAndTime(date time.Time, micros int64) time.Time {
	base := time.Date(date.Year(), date.Month(), date.Day(), 0, 0, 0, 0, date.Location())
	return base.Add(time.Duration(micros) * time.Microsecond)
}
