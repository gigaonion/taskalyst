// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: time_entries.sql

package repository

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createTimeEntry = `-- name: CreateTimeEntry :one
INSERT INTO time_entries (
  user_id, project_id, task_id, started_at,ended_at, note
) VALUES (
    $1, $2, $3, $4, $5 ,$6
) RETURNING id, user_id, project_id, task_id, started_at, ended_at, note, is_auto_generated, created_at, updated_at
`

type CreateTimeEntryParams struct {
	UserID    uuid.UUID          `json:"user_id"`
	ProjectID uuid.UUID          `json:"project_id"`
	TaskID    pgtype.UUID        `json:"task_id"`
	StartedAt pgtype.Timestamptz `json:"started_at"`
	EndedAt   pgtype.Timestamptz `json:"ended_at"`
	Note      pgtype.Text        `json:"note"`
}

func (q *Queries) CreateTimeEntry(ctx context.Context, arg CreateTimeEntryParams) (TimeEntry, error) {
	row := q.db.QueryRow(ctx, createTimeEntry,
		arg.UserID,
		arg.ProjectID,
		arg.TaskID,
		arg.StartedAt,
		arg.EndedAt,
		arg.Note,
	)
	var i TimeEntry
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProjectID,
		&i.TaskID,
		&i.StartedAt,
		&i.EndedAt,
		&i.Note,
		&i.IsAutoGenerated,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getGrowthStats = `-- name: GetGrowthStats :many
SELECT
    DATE(te.started_at)::text as date,
    SUM(EXTRACT(EPOCH FROM (COALESCE(te.ended_at, NOW()) - te.started_at)))::bigint as total_seconds
FROM time_entries te
JOIN projects p ON te.project_id = p.id
JOIN categories c ON p.category_id = c.id
WHERE
    te.user_id = $1
    AND c.root_type = 'GROWTH'
    AND te.started_at >= $2
    AND te.started_at <= $3
GROUP BY DATE(te.started_at)
ORDER BY date
`

type GetGrowthStatsParams struct {
	UserID   uuid.UUID          `json:"user_id"`
	FromDate pgtype.Timestamptz `json:"from_date"`
	ToDate   pgtype.Timestamptz `json:"to_date"`
}

type GetGrowthStatsRow struct {
	Date         string `json:"date"`
	TotalSeconds int64  `json:"total_seconds"`
}

// GROWTHカテゴリの実績のみを日別集計
func (q *Queries) GetGrowthStats(ctx context.Context, arg GetGrowthStatsParams) ([]GetGrowthStatsRow, error) {
	rows, err := q.db.Query(ctx, getGrowthStats, arg.UserID, arg.FromDate, arg.ToDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGrowthStatsRow
	for rows.Next() {
		var i GetGrowthStatsRow
		if err := rows.Scan(&i.Date, &i.TotalSeconds); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRunningTimeEntries = `-- name: GetRunningTimeEntries :many
SELECT t.id, t.user_id, t.project_id, t.task_id, t.started_at, t.ended_at, t.note, t.is_auto_generated, t.created_at, t.updated_at, p.title as project_title, COALESCE(p.color, '#808080')::varchar as project_color
FROM time_entries t
JOIN projects p ON t.project_id = p.id
WHERE t.user_id = $1 AND t.ended_at IS NULL
ORDER BY t.started_at DESC
`

type GetRunningTimeEntriesRow struct {
	ID              uuid.UUID          `json:"id"`
	UserID          uuid.UUID          `json:"user_id"`
	ProjectID       uuid.UUID          `json:"project_id"`
	TaskID          pgtype.UUID        `json:"task_id"`
	StartedAt       pgtype.Timestamptz `json:"started_at"`
	EndedAt         pgtype.Timestamptz `json:"ended_at"`
	Note            pgtype.Text        `json:"note"`
	IsAutoGenerated bool               `json:"is_auto_generated"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
	ProjectTitle    string             `json:"project_title"`
	ProjectColor    string             `json:"project_color"`
}

// 計測中のエントリ
func (q *Queries) GetRunningTimeEntries(ctx context.Context, userID uuid.UUID) ([]GetRunningTimeEntriesRow, error) {
	rows, err := q.db.Query(ctx, getRunningTimeEntries, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRunningTimeEntriesRow
	for rows.Next() {
		var i GetRunningTimeEntriesRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ProjectID,
			&i.TaskID,
			&i.StartedAt,
			&i.EndedAt,
			&i.Note,
			&i.IsAutoGenerated,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProjectTitle,
			&i.ProjectColor,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTimeEntries = `-- name: ListTimeEntries :many
SELECT t.id, t.user_id, t.project_id, t.task_id, t.started_at, t.ended_at, t.note, t.is_auto_generated, t.created_at, t.updated_at, p.title as project_title, COALESCE(p.color, '#808080')::varchar as project_color
FROM time_entries t
JOIN projects p ON t.project_id = p.id
WHERE 
    t.user_id = $1
    AND t.started_at >= $2
    AND t.started_at <= $3
ORDER BY t.started_at DESC
`

type ListTimeEntriesParams struct {
	UserID   uuid.UUID          `json:"user_id"`
	FromDate pgtype.Timestamptz `json:"from_date"`
	ToDate   pgtype.Timestamptz `json:"to_date"`
}

type ListTimeEntriesRow struct {
	ID              uuid.UUID          `json:"id"`
	UserID          uuid.UUID          `json:"user_id"`
	ProjectID       uuid.UUID          `json:"project_id"`
	TaskID          pgtype.UUID        `json:"task_id"`
	StartedAt       pgtype.Timestamptz `json:"started_at"`
	EndedAt         pgtype.Timestamptz `json:"ended_at"`
	Note            pgtype.Text        `json:"note"`
	IsAutoGenerated bool               `json:"is_auto_generated"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
	ProjectTitle    string             `json:"project_title"`
	ProjectColor    string             `json:"project_color"`
}

func (q *Queries) ListTimeEntries(ctx context.Context, arg ListTimeEntriesParams) ([]ListTimeEntriesRow, error) {
	rows, err := q.db.Query(ctx, listTimeEntries, arg.UserID, arg.FromDate, arg.ToDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTimeEntriesRow
	for rows.Next() {
		var i ListTimeEntriesRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ProjectID,
			&i.TaskID,
			&i.StartedAt,
			&i.EndedAt,
			&i.Note,
			&i.IsAutoGenerated,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProjectTitle,
			&i.ProjectColor,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const stopTimeEntry = `-- name: StopTimeEntry :one
UPDATE time_entries
SET ended_at = $3, updated_at = NOW()
WHERE id = $1 AND user_id = $2
RETURNING id, user_id, project_id, task_id, started_at, ended_at, note, is_auto_generated, created_at, updated_at
`

type StopTimeEntryParams struct {
	ID      uuid.UUID          `json:"id"`
	UserID  uuid.UUID          `json:"user_id"`
	EndedAt pgtype.Timestamptz `json:"ended_at"`
}

func (q *Queries) StopTimeEntry(ctx context.Context, arg StopTimeEntryParams) (TimeEntry, error) {
	row := q.db.QueryRow(ctx, stopTimeEntry, arg.ID, arg.UserID, arg.EndedAt)
	var i TimeEntry
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProjectID,
		&i.TaskID,
		&i.StartedAt,
		&i.EndedAt,
		&i.Note,
		&i.IsAutoGenerated,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateTimeEntry = `-- name: UpdateTimeEntry :one
UPDATE time_entries
SET 
    project_id = COALESCE($3, project_id),
    task_id = COALESCE($4, task_id),
    started_at = COALESCE($5, started_at),
    ended_at = COALESCE($6, ended_at),
    note = COALESCE($7, note),
    updated_at = NOW()
WHERE id = $1 AND user_id = $2
RETURNING id, user_id, project_id, task_id, started_at, ended_at, note, is_auto_generated, created_at, updated_at
`

type UpdateTimeEntryParams struct {
	ID        uuid.UUID          `json:"id"`
	UserID    uuid.UUID          `json:"user_id"`
	ProjectID pgtype.UUID        `json:"project_id"`
	TaskID    pgtype.UUID        `json:"task_id"`
	StartedAt pgtype.Timestamptz `json:"started_at"`
	EndedAt   pgtype.Timestamptz `json:"ended_at"`
	Note      pgtype.Text        `json:"note"`
}

func (q *Queries) UpdateTimeEntry(ctx context.Context, arg UpdateTimeEntryParams) (TimeEntry, error) {
	row := q.db.QueryRow(ctx, updateTimeEntry,
		arg.ID,
		arg.UserID,
		arg.ProjectID,
		arg.TaskID,
		arg.StartedAt,
		arg.EndedAt,
		arg.Note,
	)
	var i TimeEntry
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProjectID,
		&i.TaskID,
		&i.StartedAt,
		&i.EndedAt,
		&i.Note,
		&i.IsAutoGenerated,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
