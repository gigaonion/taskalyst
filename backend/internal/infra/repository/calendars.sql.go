// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: calendars.sql

package repository

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createCalendar = `-- name: CreateCalendar :one
INSERT INTO calendars (
    user_id, name, color, description
) VALUES (
    $1, $2, $3, $4
) RETURNING id, user_id, name, color, description, sync_token, supported_components, created_at, updated_at
`

type CreateCalendarParams struct {
	UserID      uuid.UUID   `json:"user_id"`
	Name        string      `json:"name"`
	Color       pgtype.Text `json:"color"`
	Description pgtype.Text `json:"description"`
}

func (q *Queries) CreateCalendar(ctx context.Context, arg CreateCalendarParams) (Calendar, error) {
	row := q.db.QueryRow(ctx, createCalendar,
		arg.UserID,
		arg.Name,
		arg.Color,
		arg.Description,
	)
	var i Calendar
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Color,
		&i.Description,
		&i.SyncToken,
		&i.SupportedComponents,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createEvent = `-- name: CreateEvent :one
INSERT INTO scheduled_events (
    user_id, project_id, calendar_id,
    title, description, location,
    start_at, end_at, is_all_day,
    ical_uid, status, rrule
) VALUES (
    $1, $2, $3,
    $4, $5, $6,
    $7, $8, $9,
    $10, $11, $12
) RETURNING id, user_id, project_id, calendar_id, title, description, location, start_at, end_at, is_all_day, external_event_id, ical_uid, etag, sequence, status, transparency, rrule, dtstamp, url, created_at, updated_at
`

type CreateEventParams struct {
	UserID      uuid.UUID          `json:"user_id"`
	ProjectID   uuid.UUID          `json:"project_id"`
	CalendarID  pgtype.UUID        `json:"calendar_id"`
	Title       string             `json:"title"`
	Description pgtype.Text        `json:"description"`
	Location    pgtype.Text        `json:"location"`
	StartAt     pgtype.Timestamptz `json:"start_at"`
	EndAt       pgtype.Timestamptz `json:"end_at"`
	IsAllDay    bool               `json:"is_all_day"`
	IcalUid     pgtype.Text        `json:"ical_uid"`
	Status      pgtype.Text        `json:"status"`
	Rrule       pgtype.Text        `json:"rrule"`
}

func (q *Queries) CreateEvent(ctx context.Context, arg CreateEventParams) (ScheduledEvent, error) {
	row := q.db.QueryRow(ctx, createEvent,
		arg.UserID,
		arg.ProjectID,
		arg.CalendarID,
		arg.Title,
		arg.Description,
		arg.Location,
		arg.StartAt,
		arg.EndAt,
		arg.IsAllDay,
		arg.IcalUid,
		arg.Status,
		arg.Rrule,
	)
	var i ScheduledEvent
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProjectID,
		&i.CalendarID,
		&i.Title,
		&i.Description,
		&i.Location,
		&i.StartAt,
		&i.EndAt,
		&i.IsAllDay,
		&i.ExternalEventID,
		&i.IcalUid,
		&i.Etag,
		&i.Sequence,
		&i.Status,
		&i.Transparency,
		&i.Rrule,
		&i.Dtstamp,
		&i.Url,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createTimetableSlot = `-- name: CreateTimetableSlot :one
INSERT INTO timetable_slots (
    user_id, project_id, day_of_week, start_time, end_time, location, note
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
) RETURNING id, user_id, project_id, day_of_week, start_time, end_time, note, location
`

type CreateTimetableSlotParams struct {
	UserID    uuid.UUID   `json:"user_id"`
	ProjectID uuid.UUID   `json:"project_id"`
	DayOfWeek int16       `json:"day_of_week"`
	StartTime pgtype.Time `json:"start_time"`
	EndTime   pgtype.Time `json:"end_time"`
	Location  pgtype.Text `json:"location"`
	Note      pgtype.Text `json:"note"`
}

func (q *Queries) CreateTimetableSlot(ctx context.Context, arg CreateTimetableSlotParams) (TimetableSlot, error) {
	row := q.db.QueryRow(ctx, createTimetableSlot,
		arg.UserID,
		arg.ProjectID,
		arg.DayOfWeek,
		arg.StartTime,
		arg.EndTime,
		arg.Location,
		arg.Note,
	)
	var i TimetableSlot
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProjectID,
		&i.DayOfWeek,
		&i.StartTime,
		&i.EndTime,
		&i.Note,
		&i.Location,
	)
	return i, err
}

const deleteCalendar = `-- name: DeleteCalendar :exec
DELETE FROM calendars
WHERE id = $1 AND user_id = $2
`

type DeleteCalendarParams struct {
	ID     uuid.UUID `json:"id"`
	UserID uuid.UUID `json:"user_id"`
}

func (q *Queries) DeleteCalendar(ctx context.Context, arg DeleteCalendarParams) error {
	_, err := q.db.Exec(ctx, deleteCalendar, arg.ID, arg.UserID)
	return err
}

const getEventByICalUID = `-- name: GetEventByICalUID :one
SELECT id, user_id, project_id, calendar_id, title, description, location, start_at, end_at, is_all_day, external_event_id, ical_uid, etag, sequence, status, transparency, rrule, dtstamp, url, created_at, updated_at FROM scheduled_events
WHERE user_id = $1 AND ical_uid = $2 LIMIT 1
`

type GetEventByICalUIDParams struct {
	UserID  uuid.UUID   `json:"user_id"`
	IcalUid pgtype.Text `json:"ical_uid"`
}

func (q *Queries) GetEventByICalUID(ctx context.Context, arg GetEventByICalUIDParams) (ScheduledEvent, error) {
	row := q.db.QueryRow(ctx, getEventByICalUID, arg.UserID, arg.IcalUid)
	var i ScheduledEvent
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProjectID,
		&i.CalendarID,
		&i.Title,
		&i.Description,
		&i.Location,
		&i.StartAt,
		&i.EndAt,
		&i.IsAllDay,
		&i.ExternalEventID,
		&i.IcalUid,
		&i.Etag,
		&i.Sequence,
		&i.Status,
		&i.Transparency,
		&i.Rrule,
		&i.Dtstamp,
		&i.Url,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listCalendars = `-- name: ListCalendars :many
SELECT id, user_id, name, color, description, sync_token, supported_components, created_at, updated_at FROM calendars
WHERE user_id = $1
ORDER BY created_at
`

func (q *Queries) ListCalendars(ctx context.Context, userID uuid.UUID) ([]Calendar, error) {
	rows, err := q.db.Query(ctx, listCalendars, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Calendar
	for rows.Next() {
		var i Calendar
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Color,
			&i.Description,
			&i.SyncToken,
			&i.SupportedComponents,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEventsByRange = `-- name: ListEventsByRange :many
SELECT e.id, e.user_id, e.project_id, e.calendar_id, e.title, e.description, e.location, e.start_at, e.end_at, e.is_all_day, e.external_event_id, e.ical_uid, e.etag, e.sequence, e.status, e.transparency, e.rrule, e.dtstamp, e.url, e.created_at, e.updated_at, p.title as project_title, p.category_id
FROM scheduled_events e
JOIN projects p ON e.project_id = p.id
WHERE
    e.user_id = $1
    AND e.end_at >= $2
    AND e.start_at <= $3
ORDER BY e.start_at ASC
`

type ListEventsByRangeParams struct {
	UserID    uuid.UUID          `json:"user_id"`
	StartTime pgtype.Timestamptz `json:"start_time"`
	EndTime   pgtype.Timestamptz `json:"end_time"`
}

type ListEventsByRangeRow struct {
	ID              uuid.UUID          `json:"id"`
	UserID          uuid.UUID          `json:"user_id"`
	ProjectID       uuid.UUID          `json:"project_id"`
	CalendarID      pgtype.UUID        `json:"calendar_id"`
	Title           string             `json:"title"`
	Description     pgtype.Text        `json:"description"`
	Location        pgtype.Text        `json:"location"`
	StartAt         pgtype.Timestamptz `json:"start_at"`
	EndAt           pgtype.Timestamptz `json:"end_at"`
	IsAllDay        bool               `json:"is_all_day"`
	ExternalEventID pgtype.Text        `json:"external_event_id"`
	IcalUid         pgtype.Text        `json:"ical_uid"`
	Etag            pgtype.Text        `json:"etag"`
	Sequence        int32              `json:"sequence"`
	Status          pgtype.Text        `json:"status"`
	Transparency    pgtype.Text        `json:"transparency"`
	Rrule           pgtype.Text        `json:"rrule"`
	Dtstamp         pgtype.Timestamptz `json:"dtstamp"`
	Url             pgtype.Text        `json:"url"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
	ProjectTitle    string             `json:"project_title"`
	CategoryID      uuid.UUID          `json:"category_id"`
}

func (q *Queries) ListEventsByRange(ctx context.Context, arg ListEventsByRangeParams) ([]ListEventsByRangeRow, error) {
	rows, err := q.db.Query(ctx, listEventsByRange, arg.UserID, arg.StartTime, arg.EndTime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListEventsByRangeRow
	for rows.Next() {
		var i ListEventsByRangeRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ProjectID,
			&i.CalendarID,
			&i.Title,
			&i.Description,
			&i.Location,
			&i.StartAt,
			&i.EndAt,
			&i.IsAllDay,
			&i.ExternalEventID,
			&i.IcalUid,
			&i.Etag,
			&i.Sequence,
			&i.Status,
			&i.Transparency,
			&i.Rrule,
			&i.Dtstamp,
			&i.Url,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProjectTitle,
			&i.CategoryID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTimetableSlots = `-- name: ListTimetableSlots :many
SELECT ts.id, ts.user_id, ts.project_id, ts.day_of_week, ts.start_time, ts.end_time, ts.note, ts.location, p.title as project_title, p.color as project_color
FROM timetable_slots ts
JOIN projects p ON ts.project_id = p.id
WHERE ts.user_id = $1
ORDER BY ts.day_of_week, ts.start_time
`

type ListTimetableSlotsRow struct {
	ID           uuid.UUID   `json:"id"`
	UserID       uuid.UUID   `json:"user_id"`
	ProjectID    uuid.UUID   `json:"project_id"`
	DayOfWeek    int16       `json:"day_of_week"`
	StartTime    pgtype.Time `json:"start_time"`
	EndTime      pgtype.Time `json:"end_time"`
	Note         pgtype.Text `json:"note"`
	Location     pgtype.Text `json:"location"`
	ProjectTitle string      `json:"project_title"`
	ProjectColor pgtype.Text `json:"project_color"`
}

func (q *Queries) ListTimetableSlots(ctx context.Context, userID uuid.UUID) ([]ListTimetableSlotsRow, error) {
	rows, err := q.db.Query(ctx, listTimetableSlots, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTimetableSlotsRow
	for rows.Next() {
		var i ListTimetableSlotsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ProjectID,
			&i.DayOfWeek,
			&i.StartTime,
			&i.EndTime,
			&i.Note,
			&i.Location,
			&i.ProjectTitle,
			&i.ProjectColor,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
