// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: results.sql

package repository

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createResult = `-- name: CreateResult :one
INSERT INTO results (
    user_id, project_id, target_task_id, type, value, recorded_at, note
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
) RETURNING id, user_id, project_id, target_task_id, type, value, recorded_at, note
`

type CreateResultParams struct {
	UserID       uuid.UUID          `json:"user_id"`
	ProjectID    uuid.UUID          `json:"project_id"`
	TargetTaskID pgtype.UUID        `json:"target_task_id"`
	Type         string             `json:"type"`
	Value        pgtype.Numeric     `json:"value"`
	RecordedAt   pgtype.Timestamptz `json:"recorded_at"`
	Note         pgtype.Text        `json:"note"`
}

func (q *Queries) CreateResult(ctx context.Context, arg CreateResultParams) (Result, error) {
	row := q.db.QueryRow(ctx, createResult,
		arg.UserID,
		arg.ProjectID,
		arg.TargetTaskID,
		arg.Type,
		arg.Value,
		arg.RecordedAt,
		arg.Note,
	)
	var i Result
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProjectID,
		&i.TargetTaskID,
		&i.Type,
		&i.Value,
		&i.RecordedAt,
		&i.Note,
	)
	return i, err
}

const deleteResult = `-- name: DeleteResult :exec
DELETE FROM results
WHERE id = $1 AND user_id = $2
`

type DeleteResultParams struct {
	ID     uuid.UUID `json:"id"`
	UserID uuid.UUID `json:"user_id"`
}

func (q *Queries) DeleteResult(ctx context.Context, arg DeleteResultParams) error {
	_, err := q.db.Exec(ctx, deleteResult, arg.ID, arg.UserID)
	return err
}

const listResults = `-- name: ListResults :many
SELECT 
    r.id, r.user_id, r.project_id, r.target_task_id, r.type, r.value, r.recorded_at, r.note, 
    p.title as project_title, 
    COALESCE(p.color, '#808080')::varchar as project_color, 
    COALESCE(t.title, '')::varchar as task_title
FROM results r
JOIN projects p ON r.project_id = p.id
LEFT JOIN tasks t ON r.target_task_id = t.id
WHERE
    r.user_id = $1
    AND ($2::uuid IS NULL OR r.project_id = $2)
    AND r.recorded_at >= $3
    AND r.recorded_at <= $4
ORDER BY r.recorded_at DESC
`

type ListResultsParams struct {
	UserID    uuid.UUID          `json:"user_id"`
	ProjectID pgtype.UUID        `json:"project_id"`
	FromDate  pgtype.Timestamptz `json:"from_date"`
	ToDate    pgtype.Timestamptz `json:"to_date"`
}

type ListResultsRow struct {
	ID           uuid.UUID          `json:"id"`
	UserID       uuid.UUID          `json:"user_id"`
	ProjectID    uuid.UUID          `json:"project_id"`
	TargetTaskID pgtype.UUID        `json:"target_task_id"`
	Type         string             `json:"type"`
	Value        pgtype.Numeric     `json:"value"`
	RecordedAt   pgtype.Timestamptz `json:"recorded_at"`
	Note         pgtype.Text        `json:"note"`
	ProjectTitle string             `json:"project_title"`
	ProjectColor string             `json:"project_color"`
	TaskTitle    string             `json:"task_title"`
}

func (q *Queries) ListResults(ctx context.Context, arg ListResultsParams) ([]ListResultsRow, error) {
	rows, err := q.db.Query(ctx, listResults,
		arg.UserID,
		arg.ProjectID,
		arg.FromDate,
		arg.ToDate,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListResultsRow
	for rows.Next() {
		var i ListResultsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ProjectID,
			&i.TargetTaskID,
			&i.Type,
			&i.Value,
			&i.RecordedAt,
			&i.Note,
			&i.ProjectTitle,
			&i.ProjectColor,
			&i.TaskTitle,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
